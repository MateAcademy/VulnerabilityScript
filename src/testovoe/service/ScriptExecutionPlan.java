package testovoe.service;

import testovoe.db.Storage;
import testovoe.model.VulnerabilityScript;
import testovoe.model.KeyValueMap;

import java.util.*;

public class ScriptExecutionPlan {
    private static Set<Integer> executionPlan = new LinkedHashSet<>();

    public void start() {
        try {
            long startTme = System.currentTimeMillis();
            List<VulnerabilityScript> scripts = Storage.getScriptList();

            scriptExecutionPlanFromDatabase(scripts);

            System.out.println("Execution Plan: " + executionPlan);
            long endTime = System.currentTimeMillis();
            System.out.println("time ms: " + (endTime - startTme));
        } catch (Exception e) {
            System.err.println("The program ended with errors " + e);
        }
    }

    private static void scriptExecutionPlanFromDatabase(List<VulnerabilityScript> scripts) {
        List<KeyValueMap> mapList = getListKeyValueMapFromScriptsList(scripts);
        findAndPutInExecutionPlanLastValueOfTheScript(mapList);

        while (!mapList.isEmpty()) {
            processSingleRecordsInMapListScripts(mapList);
            processDuplicateRecordsInMapListScripts(mapList);
        }
    }

    private static List<KeyValueMap> getListKeyValueMapFromScriptsList(List<VulnerabilityScript> scripts) {
        List<KeyValueMap> keyValueList = new ArrayList<>();

        for (VulnerabilityScript vs : scripts) {
            int scriptId = vs.getScriptId();
            List<Integer> dependencies = vs.getDependencies();
            int numberOfDependencies = dependencies.size();

            KeyValueMap keyValueMap = new KeyValueMap();

            if (numberOfDependencies == 1) {
                Map<Integer, Integer> map = new HashMap<>();
                map.put(dependencies.get(0), 1);

                keyValueMap.setKey(scriptId);
                keyValueMap.setValue(map);
                keyValueList.add(keyValueMap);
            } else if (numberOfDependencies > 1) {
                for (Integer counter : dependencies) {
                    Map<Integer, Integer> map = new HashMap<>();
                    map.put(counter, numberOfDependencies);
                    keyValueMap.setKey(scriptId);
                    keyValueMap.setValue(map);

                    keyValueList.add(keyValueMap);
                }
            } else if (numberOfDependencies == 0) {
                Map<Integer, Integer> map = new HashMap<>();
                map.put(0, 1);

                keyValueMap.setKey(scriptId);
                keyValueMap.setValue(map);

                keyValueList.add(keyValueMap);
            }
        }
        return keyValueList;
    }

    private static void findAndPutInExecutionPlanLastValueOfTheScript(List<KeyValueMap> keyValueMaps) {
        if (keyValueMaps != null && !keyValueMaps.isEmpty()) {
            Iterator<KeyValueMap> iterator = keyValueMaps.iterator();

            while (iterator.hasNext()) {
                KeyValueMap element = iterator.next();
                if (element.getValue().containsKey(0)) {
                    int valueForExecutionPlan = element.getKey();
                    executionPlan.add(valueForExecutionPlan);
                    iterator.remove();
                }
            }
        }
    }

    private static void processSingleRecordsInMapListScripts(List<KeyValueMap> keyValueMaps) {
        if (keyValueMaps != null && !keyValueMaps.isEmpty()) {
            Iterator<KeyValueMap> iterator = keyValueMaps.iterator();

            while (iterator.hasNext()) {
                KeyValueMap element = iterator.next();
                int key = element.getKey();
                Map<Integer, Integer> value = element.getValue();

                for (Map.Entry<Integer, Integer> entries : value.entrySet()) {
                    Integer keyFromMyMap = entries.getKey();
                    Integer valueFromMyMap = entries.getValue();

                    if (valueFromMyMap == 1 && executionPlan.contains(keyFromMyMap)) {
                        executionPlan.add(key);
                        iterator.remove();
                    }
                }
            }
        }
    }

    private static void processDuplicateRecordsInMapListScripts(List<KeyValueMap> keyValueMaps) {
        if (keyValueMaps != null && !keyValueMaps.isEmpty()) {
            List<Integer> listToDelete = new ArrayList<>();

            keyValueMaps.sort(Comparator.comparingInt(KeyValueMap::getKey));
            Iterator<KeyValueMap> iterator = keyValueMaps.iterator();

            Integer keyDuplicat = null;
            int count = 0;
            boolean delite = false;

            while (iterator.hasNext()) {
                KeyValueMap element = iterator.next();
                int key = element.getKey();

                if (!Objects.equals(key, keyDuplicat)) {
                    keyDuplicat = key;
                    count = 1;
                    delite = false;
                } else if (keyDuplicat == key) {
                    count++;
                }

                Map<Integer, Integer> value = element.getValue();

                for (Map.Entry<Integer, Integer> entries : value.entrySet()) {
                    int keyFromMyMap = entries.getKey();
                    int valueFromMyMap = entries.getValue();

                    if (count == 1 && executionPlan.contains(keyFromMyMap)) {
                        delite = true;
                    } else if (count > 1 && executionPlan.contains(keyFromMyMap) && delite) {
                        delite = true;
                    } else {
                        delite = false;
                    }

                    if (valueFromMyMap == count && delite) {
                        executionPlan.add(key);
                        listToDelete.add(element.getKey());
                    }
                }
            }

            if (!listToDelete.isEmpty()) {
                Iterator<KeyValueMap> iterator2 = keyValueMaps.iterator();
                while (iterator2.hasNext()) {
                    KeyValueMap element2 = iterator2.next();
                    Integer key1 = element2.getKey();
                    if (listToDelete.contains(key1)) {
                        iterator2.remove();
                    }
                }
            }
        }
    }

}
